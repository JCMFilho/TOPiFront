import { __assign, __decorate, __metadata, __param, __read, __spread } from "tslib";
import { Directive, Input, ElementRef, TemplateRef, ViewContainerRef, OnDestroy, OnChanges, SimpleChanges, Output, EventEmitter, Renderer2, HostListener, Optional, Inject } from '@angular/core';
import { OverlayRef, Overlay, FlexibleConnectedPositionStrategy } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { map, distinctUntilChanged } from 'rxjs/operators';
import { NglTooltip } from './tooltip';
import { POSITION_MAP, DEFAULT_TOOLTIP_POSITIONS, getPlacementName } from '../util/overlay-position';
import { uniqueId } from '../util/util';
import { InputBoolean } from '../util/convert';
import { NGL_TOOLTIP_CONFIG, NglTooltipConfig } from './config';
var NglTooltipTrigger = /** @class */ (function () {
    function NglTooltipTrigger(defaultConfig, element, renderer, viewContainerRef, overlay) {
        this.element = element;
        this.renderer = renderer;
        this.viewContainerRef = viewContainerRef;
        this.overlay = overlay;
        /**
         * Emit an event when actual tooltip is shown or hidden.
         */
        this.nglTooltipOpenChange = new EventEmitter();
        this.uid = uniqueId('tooltip');
        /** Names of properties that should be proxy to child component. */
        this.needProxyProperties = new Set([
            'template',
            'placement',
            'uid',
            'tooltipClass',
        ]);
        this.openDelay = 0;
        this.closeDelay = 0;
        this.toggleTimeout = null;
        this.overlayListeners = new Set();
        this.config = __assign(__assign({}, new NglTooltipConfig()), defaultConfig);
        this.openAuto = this.config.openAuto;
        this.interactive = this.config.interactive;
        this.delay = this.config.delay;
        this.renderer.setAttribute(this.element.nativeElement, 'aria-describedby', this.uid);
    }
    Object.defineProperty(NglTooltipTrigger.prototype, "placement", {
        get: function () {
            return this._placement || this.config.placement;
        },
        /**
         * Position relative to host element.
         */
        set: function (placement) {
            if (placement === this.placement) {
                return;
            }
            this._placement = placement;
            if (this.overlayRef) {
                this.updatePosition();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglTooltipTrigger.prototype, "delay", {
        /**
         * Delay in milliseconds until it opens/closes.
         */
        set: function (_delay) {
            var _a;
            var delay = Array.isArray(_delay) ? _delay : [_delay, _delay];
            _a = __read(delay.map(Number), 2), this.openDelay = _a[0], this.closeDelay = _a[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NglTooltipTrigger.prototype, "nglOpen", {
        get: function () {
            return this._open;
        },
        /**
         * Whether the floating tooltip is visible.
         */
        set: function (open) {
            if (open === this.nglOpen) {
                return;
            }
            open ? this.create() : this.detach();
            this._open = open;
        },
        enumerable: true,
        configurable: true
    });
    NglTooltipTrigger.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (this.nglOpen) {
            this.updateProxies(changes);
            Promise.resolve().then(function () {
                if (_this.overlayRef) {
                    _this.overlayRef.updatePosition();
                }
            });
        }
    };
    NglTooltipTrigger.prototype.onMouseOver = function () {
        this.open();
    };
    NglTooltipTrigger.prototype.onMouseOut = function () {
        var _this = this;
        this.close();
        if (this.overlayRef && !this.overlayElement && this.interactive) {
            this.overlayElement = this.overlayRef.overlayElement;
            this.overlayListeners.add(this.renderer.listen(this.overlayElement, 'mouseenter', function () { return _this.open(); }));
            this.overlayListeners.add(this.renderer.listen(this.overlayElement, 'mouseleave', function () { return _this.close(); }));
        }
    };
    NglTooltipTrigger.prototype.ngOnDestroy = function () {
        this.detach();
        this.close(0);
    };
    // Expose open method
    NglTooltipTrigger.prototype.open = function (delay) {
        if (delay === void 0) { delay = this.openDelay; }
        this.handle(true, delay);
    };
    // Expose close method
    NglTooltipTrigger.prototype.close = function (delay) {
        if (delay === void 0) { delay = this.closeDelay; }
        this.handle(false, delay);
    };
    // Expose toggle method
    NglTooltipTrigger.prototype.toggle = function () {
        this.nglOpen ? this.close(0) : this.open(0);
    };
    NglTooltipTrigger.prototype.handle = function (open, delay) {
        var _this = this;
        if (this.toggleTimeout !== null) {
            clearTimeout(this.toggleTimeout);
            this.toggleTimeout = null;
        }
        if (open !== this.nglOpen) {
            if (delay > 0) {
                this.toggleTimeout = setTimeout(function () {
                    _this.toggleTimeout = null;
                    _this.emitOpen(open);
                }, delay);
            }
            else {
                this.emitOpen(open);
            }
        }
    };
    NglTooltipTrigger.prototype.emitOpen = function (open) {
        if (this.openAuto) {
            this.nglOpen = open;
        }
        this.nglTooltipOpenChange.emit(open);
    };
    NglTooltipTrigger.prototype.create = function () {
        var _this = this;
        if (this.nglOpen) {
            return;
        }
        this.detach();
        var overlayRef = this.createOverlay();
        this.portal = this.portal || new ComponentPortal(NglTooltip, this.viewContainerRef);
        this.tooltip = overlayRef.attach(this.portal).instance;
        this.needProxyProperties.forEach(function (property) { return _this.updateTooltip(property, _this[property]); });
    };
    /** Detaches the currently-attached tooltip. */
    NglTooltipTrigger.prototype.detach = function () {
        if (this.overlayRef) {
            this.overlayRef.detach();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
        // Clean up the event listeners
        this.overlayListeners.forEach(function (unlisten) { return unlisten(); });
        this.overlayListeners.clear();
        // Clear the overlay reference used for interactive mode
        if (this.interactive) {
            this.overlayElement = null;
        }
        if (this.positionChangesSubscription) {
            this.positionChangesSubscription.unsubscribe();
            this.positionChangesSubscription = null;
        }
        this.tooltip = null;
    };
    /** Create the overlay config and position strategy */
    NglTooltipTrigger.prototype.createOverlay = function () {
        var _this = this;
        if (this.overlayRef) {
            return this.overlayRef;
        }
        // Create connected position strategy that listens for scroll events to reposition.
        var strategy = this.overlay.position()
            .flexibleConnectedTo(this.element)
            .withFlexibleDimensions(false)
            .withViewportMargin(8)
            .withPush(false);
        this.positionChangesSubscription = strategy.positionChanges
            .pipe(map(function (change) { return getPlacementName(change, _this.placement); }), distinctUntilChanged())
            .subscribe(function (placement) {
            _this.updatePosition();
            _this.updateTooltip('placement', placement);
        });
        this.overlayRef = this.overlay.create({
            positionStrategy: strategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.updatePosition();
        return this.overlayRef;
    };
    /** Updates the position of the current tooltip. */
    NglTooltipTrigger.prototype.updatePosition = function () {
        var position = this.overlayRef.getConfig().positionStrategy;
        position.withPositions(__spread([
            POSITION_MAP[this.placement].position
        ], DEFAULT_TOOLTIP_POSITIONS));
    };
    NglTooltipTrigger.prototype.updateTooltip = function (key, value) {
        this.tooltip[key] = value;
    };
    /**
     * Set inputs of child components when this component's inputs change.
     */
    NglTooltipTrigger.prototype.updateProxies = function (changes) {
        var _this = this;
        Object.keys(changes)
            .filter(function (key) { return _this.needProxyProperties.has(key); })
            .forEach(function (key) { return _this.updateTooltip(key, _this[key]); });
    };
    NglTooltipTrigger.ctorParameters = function () { return [
        { type: NglTooltipConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_TOOLTIP_CONFIG,] }] },
        { type: ElementRef },
        { type: Renderer2 },
        { type: ViewContainerRef },
        { type: Overlay }
    ]; };
    __decorate([
        Input('nglTooltip'),
        __metadata("design:type", Object)
    ], NglTooltipTrigger.prototype, "template", void 0);
    __decorate([
        Input('nglTooltipPlacement'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], NglTooltipTrigger.prototype, "placement", null);
    __decorate([
        Input('nglTooltipDelay'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], NglTooltipTrigger.prototype, "delay", null);
    __decorate([
        Input('nglTooltipOpen'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], NglTooltipTrigger.prototype, "nglOpen", null);
    __decorate([
        Input('nglTooltipOpenAuto'), InputBoolean(),
        __metadata("design:type", Boolean)
    ], NglTooltipTrigger.prototype, "openAuto", void 0);
    __decorate([
        Input('nglTooltipInteractive'), InputBoolean(),
        __metadata("design:type", Boolean)
    ], NglTooltipTrigger.prototype, "interactive", void 0);
    __decorate([
        Input('nglTooltipClass'),
        __metadata("design:type", Object)
    ], NglTooltipTrigger.prototype, "tooltipClass", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], NglTooltipTrigger.prototype, "nglTooltipOpenChange", void 0);
    __decorate([
        HostListener('mouseenter'),
        HostListener('focus'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], NglTooltipTrigger.prototype, "onMouseOver", null);
    __decorate([
        HostListener('mouseleave'),
        HostListener('blur'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], NglTooltipTrigger.prototype, "onMouseOut", null);
    NglTooltipTrigger = __decorate([
        Directive({
            selector: '[nglTooltip]',
            exportAs: 'nglTooltip',
        }),
        __param(0, Optional()), __param(0, Inject(NGL_TOOLTIP_CONFIG)),
        __metadata("design:paramtypes", [NglTooltipConfig,
            ElementRef,
            Renderer2,
            ViewContainerRef,
            Overlay])
    ], NglTooltipTrigger);
    return NglTooltipTrigger;
}());
export { NglTooltipTrigger };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJpZ2dlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWxpZ2h0bmluZy8iLCJzb3VyY2VzIjpbImxpYi90b29sdGlwcy90cmlnZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLFNBQVMsRUFDN0UsU0FBUyxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuSCxPQUFPLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzlGLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUV0RCxPQUFPLEVBQUUsR0FBRyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUN2QyxPQUFPLEVBQUUsWUFBWSxFQUFFLHlCQUF5QixFQUFFLGdCQUFnQixFQUFhLE1BQU0sMEJBQTBCLENBQUM7QUFDaEgsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN4QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBTWhFO0lBNkZFLDJCQUFvRCxhQUErQixFQUMvRCxPQUFtQixFQUNuQixRQUFtQixFQUNuQixnQkFBa0MsRUFDbEMsT0FBZ0I7UUFIaEIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUNuQixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDbEMsWUFBTyxHQUFQLE9BQU8sQ0FBUztRQWhD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REFBc0I7SUFLM0M7UUFBekIsS0FBSyxDQUFDLGlCQUFpQixDQUFDOzsyREFBbUI7SUFLbEM7UUFBVCxNQUFNLEVBQUU7O21FQUFvRDtJQW9EN0Q7UUFGQyxZQUFZLENBQUMsWUFBWSxDQUFDO1FBQzFCLFlBQVksQ0FBQyxPQUFPLENBQUM7Ozs7d0RBR3JCO0lBSUQ7UUFGQyxZQUFZLENBQUMsWUFBWSxDQUFDO1FBQzFCLFlBQVksQ0FBQyxNQUFNLENBQUM7Ozs7dURBUXBCO0lBcklVLGlCQUFpQjtRQUo3QixTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsY0FBYztZQUN4QixRQUFRLEVBQUUsWUFBWTtTQUN2QixDQUFDO1FBOEZhLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxXQUFBLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO3lDQUFnQixnQkFBZ0I7WUFDdEQsVUFBVTtZQUNULFNBQVM7WUFDRCxnQkFBZ0I7WUFDekIsT0FBTztPQWpHekIsaUJBQWlCLENBZ1I3QjtJQUFELHdCQUFDO0NBQUEsQUFoUkQsSUFnUkM7U0FoUlksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgRWxlbWVudFJlZiwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYsIE9uRGVzdHJveSxcbiAgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgUmVuZGVyZXIyLCBIb3N0TGlzdGVuZXIsIE9wdGlvbmFsLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE92ZXJsYXlSZWYsIE92ZXJsYXksIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IENvbXBvbmVudFBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTmdsVG9vbHRpcCB9IGZyb20gJy4vdG9vbHRpcCc7XG5pbXBvcnQgeyBQT1NJVElPTl9NQVAsIERFRkFVTFRfVE9PTFRJUF9QT1NJVElPTlMsIGdldFBsYWNlbWVudE5hbWUsIFBsYWNlbWVudCB9IGZyb20gJy4uL3V0aWwvb3ZlcmxheS1wb3NpdGlvbic7XG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBJbnB1dEJvb2xlYW4gfSBmcm9tICcuLi91dGlsL2NvbnZlcnQnO1xuaW1wb3J0IHsgTkdMX1RPT0xUSVBfQ09ORklHLCBOZ2xUb29sdGlwQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbmdsVG9vbHRpcF0nLFxuICBleHBvcnRBczogJ25nbFRvb2x0aXAnLFxufSlcbmV4cG9ydCBjbGFzcyBOZ2xUb29sdGlwVHJpZ2dlciBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgYXMgc3RyaW5nIG9yIHRoZSBjb25uZWN0ZWQgdGVtcGxhdGUgcmVmZXJlbmNlIHRvIHNob3cuXG4gICAqL1xuICBASW5wdXQoJ25nbFRvb2x0aXAnKSB0ZW1wbGF0ZTogc3RyaW5nIHwgVGVtcGxhdGVSZWY8dm9pZD47XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIHJlbGF0aXZlIHRvIGhvc3QgZWxlbWVudC5cbiAgICovXG4gIEBJbnB1dCgnbmdsVG9vbHRpcFBsYWNlbWVudCcpXG4gIHNldCBwbGFjZW1lbnQocGxhY2VtZW50OiBQbGFjZW1lbnQpIHtcbiAgICBpZiAocGxhY2VtZW50ID09PSB0aGlzLnBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BsYWNlbWVudCA9IHBsYWNlbWVudDtcblxuICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHBsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxhY2VtZW50IHx8IHRoaXMuY29uZmlnLnBsYWNlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheSBpbiBtaWxsaXNlY29uZHMgdW50aWwgaXQgb3BlbnMvY2xvc2VzLlxuICAgKi9cbiAgQElucHV0KCduZ2xUb29sdGlwRGVsYXknKVxuICBzZXQgZGVsYXkoX2RlbGF5OiBhbnkgfCBhbnlbXSkge1xuICAgIGNvbnN0IGRlbGF5ID0gQXJyYXkuaXNBcnJheShfZGVsYXkpID8gX2RlbGF5IDogW19kZWxheSwgX2RlbGF5XTtcbiAgICBbdGhpcy5vcGVuRGVsYXksIHRoaXMuY2xvc2VEZWxheV0gPSBkZWxheS5tYXAoTnVtYmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBmbG9hdGluZyB0b29sdGlwIGlzIHZpc2libGUuXG4gICAqL1xuICBASW5wdXQoJ25nbFRvb2x0aXBPcGVuJykgc2V0IG5nbE9wZW4ob3BlbjogYm9vbGVhbikge1xuICAgIGlmIChvcGVuID09PSB0aGlzLm5nbE9wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvcGVuID8gdGhpcy5jcmVhdGUoKSA6IHRoaXMuZGV0YWNoKCk7XG4gICAgdGhpcy5fb3BlbiA9IG9wZW47XG4gIH1cbiAgZ2V0IG5nbE9wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW47XG4gIH1cblxuICAvKipcbiAgICogT3Blbi9jbG9zZSB3aXRob3V0IHR3by13YXkgYmluZGluZyBpbnB1dC5cbiAgICovXG4gIEBJbnB1dCgnbmdsVG9vbHRpcE9wZW5BdXRvJykgQElucHV0Qm9vbGVhbigpIG9wZW5BdXRvOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBHaXZlcyB0aGUgcG9zc2liaWxpdHkgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgY29udGVudCBvZiB0aGUgcG9wb3Zlci5cbiAgICovXG4gIEBJbnB1dCgnbmdsVG9vbHRpcEludGVyYWN0aXZlJykgQElucHV0Qm9vbGVhbigpIGludGVyYWN0aXZlOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFeHRyYSBjbGFzcyhlcykgeW91IHdhbnQgdG8gYXBwbHkgdG8gdG9vbHRpcCBob3N0IGVsZW1lbnQuXG4gICAqL1xuICBASW5wdXQoJ25nbFRvb2x0aXBDbGFzcycpIHRvb2x0aXBDbGFzczogYW55O1xuXG4gIC8qKlxuICAgKiBFbWl0IGFuIGV2ZW50IHdoZW4gYWN0dWFsIHRvb2x0aXAgaXMgc2hvd24gb3IgaGlkZGVuLlxuICAgKi9cbiAgQE91dHB1dCgpIG5nbFRvb2x0aXBPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIHVpZCA9IHVuaXF1ZUlkKCd0b29sdGlwJyk7XG5cbiAgLyoqIE5hbWVzIG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgcHJveHkgdG8gY2hpbGQgY29tcG9uZW50LiAqL1xuICBwcml2YXRlIG5lZWRQcm94eVByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgICAndGVtcGxhdGUnLFxuICAgICdwbGFjZW1lbnQnLFxuICAgICd1aWQnLFxuICAgICd0b29sdGlwQ2xhc3MnLFxuICBdKTtcbiAgcHJpdmF0ZSBfcGxhY2VtZW50OiBQbGFjZW1lbnQ7XG4gIHByaXZhdGUgX29wZW46IGJvb2xlYW47XG4gIHByaXZhdGUgcG9ydGFsOiBDb21wb25lbnRQb3J0YWw8TmdsVG9vbHRpcD47XG4gIHByaXZhdGUgb3ZlcmxheVJlZjogT3ZlcmxheVJlZiB8IG51bGw7XG4gIHByaXZhdGUgdG9vbHRpcDogTmdsVG9vbHRpcCB8IG51bGw7XG4gIHByaXZhdGUgb3BlbkRlbGF5ID0gMDtcbiAgcHJpdmF0ZSBjbG9zZURlbGF5ID0gMDtcbiAgcHJpdmF0ZSB0b2dnbGVUaW1lb3V0OiBhbnkgPSBudWxsO1xuICBwcml2YXRlIHBvc2l0aW9uQ2hhbmdlc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIG92ZXJsYXlMaXN0ZW5lcnMgPSBuZXcgU2V0PCgpID0+IHZvaWQ+KCk7XG4gIHByaXZhdGUgb3ZlcmxheUVsZW1lbnQ7XG5cbiAgcHJpdmF0ZSBjb25maWc6IE5nbFRvb2x0aXBDb25maWc7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChOR0xfVE9PTFRJUF9DT05GSUcpIGRlZmF1bHRDb25maWc6IE5nbFRvb2x0aXBDb25maWcsXG4gICAgICAgICAgICAgIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgIHByaXZhdGUgb3ZlcmxheTogT3ZlcmxheSkge1xuICAgIHRoaXMuY29uZmlnID0geyAuLi5uZXcgTmdsVG9vbHRpcENvbmZpZygpLCAuLi5kZWZhdWx0Q29uZmlnIH07XG4gICAgdGhpcy5vcGVuQXV0byA9IHRoaXMuY29uZmlnLm9wZW5BdXRvO1xuICAgIHRoaXMuaW50ZXJhY3RpdmUgPSB0aGlzLmNvbmZpZy5pbnRlcmFjdGl2ZTtcbiAgICB0aGlzLmRlbGF5ID0gdGhpcy5jb25maWcuZGVsYXk7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLnVpZCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKHRoaXMubmdsT3Blbikge1xuICAgICAgdGhpcy51cGRhdGVQcm94aWVzKGNoYW5nZXMpO1xuXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheVJlZikge1xuICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJylcbiAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxuICBvbk1vdXNlT3ZlcigpIHtcbiAgICB0aGlzLm9wZW4oKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKVxuICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgb25Nb3VzZU91dCgpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgaWYgKHRoaXMub3ZlcmxheVJlZiAmJiAhdGhpcy5vdmVybGF5RWxlbWVudCAmJiB0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICB0aGlzLm92ZXJsYXlFbGVtZW50ID0gdGhpcy5vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50O1xuICAgICAgdGhpcy5vdmVybGF5TGlzdGVuZXJzLmFkZCh0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLm92ZXJsYXlFbGVtZW50LCAnbW91c2VlbnRlcicsICgpID0+IHRoaXMub3BlbigpKSk7XG4gICAgICB0aGlzLm92ZXJsYXlMaXN0ZW5lcnMuYWRkKHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMub3ZlcmxheUVsZW1lbnQsICdtb3VzZWxlYXZlJywgKCkgPT4gdGhpcy5jbG9zZSgpKSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICB0aGlzLmNsb3NlKDApO1xuICB9XG5cbiAgLy8gRXhwb3NlIG9wZW4gbWV0aG9kXG4gIG9wZW4oZGVsYXkgPSB0aGlzLm9wZW5EZWxheSk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlKHRydWUsIGRlbGF5KTtcbiAgfVxuXG4gIC8vIEV4cG9zZSBjbG9zZSBtZXRob2RcbiAgY2xvc2UoZGVsYXkgPSB0aGlzLmNsb3NlRGVsYXkpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZShmYWxzZSwgZGVsYXkpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRvZ2dsZSBtZXRob2RcbiAgdG9nZ2xlKCk6IHZvaWQge1xuICAgIHRoaXMubmdsT3BlbiA/IHRoaXMuY2xvc2UoMCkgOiB0aGlzLm9wZW4oMCk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZShvcGVuOiBib29sZWFuLCBkZWxheTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudG9nZ2xlVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG9nZ2xlVGltZW91dCk7XG4gICAgICB0aGlzLnRvZ2dsZVRpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcGVuICE9PSB0aGlzLm5nbE9wZW4pIHtcbiAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgdGhpcy50b2dnbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy50b2dnbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmVtaXRPcGVuKG9wZW4pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXRPcGVuKG9wZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdE9wZW4ob3Blbikge1xuICAgIGlmICh0aGlzLm9wZW5BdXRvKSB7XG4gICAgICB0aGlzLm5nbE9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICB0aGlzLm5nbFRvb2x0aXBPcGVuQ2hhbmdlLmVtaXQob3Blbik7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5uZ2xPcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZXRhY2goKTtcblxuICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLmNyZWF0ZU92ZXJsYXkoKTtcblxuICAgIHRoaXMucG9ydGFsID0gdGhpcy5wb3J0YWwgfHwgbmV3IENvbXBvbmVudFBvcnRhbChOZ2xUb29sdGlwLCB0aGlzLnZpZXdDb250YWluZXJSZWYpO1xuICAgIHRoaXMudG9vbHRpcCA9IG92ZXJsYXlSZWYuYXR0YWNoKHRoaXMucG9ydGFsKS5pbnN0YW5jZTtcblxuICAgIHRoaXMubmVlZFByb3h5UHJvcGVydGllcy5mb3JFYWNoKHByb3BlcnR5ID0+IHRoaXMudXBkYXRlVG9vbHRpcChwcm9wZXJ0eSwgdGhpc1sgcHJvcGVydHkgXSkpO1xuICB9XG5cbiAgLyoqIERldGFjaGVzIHRoZSBjdXJyZW50bHktYXR0YWNoZWQgdG9vbHRpcC4gKi9cbiAgcHJpdmF0ZSBkZXRhY2goKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3ZlcmxheVJlZikge1xuICAgICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgdGhpcy5vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMub3ZlcmxheVJlZiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMub3ZlcmxheUxpc3RlbmVycy5mb3JFYWNoKCh1bmxpc3RlbikgPT4gdW5saXN0ZW4oKSk7XG4gICAgdGhpcy5vdmVybGF5TGlzdGVuZXJzLmNsZWFyKCk7XG5cbiAgICAvLyBDbGVhciB0aGUgb3ZlcmxheSByZWZlcmVuY2UgdXNlZCBmb3IgaW50ZXJhY3RpdmUgbW9kZVxuICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICB0aGlzLm92ZXJsYXlFbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wb3NpdGlvbkNoYW5nZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb25DaGFuZ2VzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlc1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy50b29sdGlwID0gbnVsbDtcbiAgfVxuXG4gIC8qKiBDcmVhdGUgdGhlIG92ZXJsYXkgY29uZmlnIGFuZCBwb3NpdGlvbiBzdHJhdGVneSAqL1xuICBwcml2YXRlIGNyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgaWYgKHRoaXMub3ZlcmxheVJlZikge1xuICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheVJlZjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgY29ubmVjdGVkIHBvc2l0aW9uIHN0cmF0ZWd5IHRoYXQgbGlzdGVucyBmb3Igc2Nyb2xsIGV2ZW50cyB0byByZXBvc2l0aW9uLlxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuZWxlbWVudClcbiAgICAgIC53aXRoRmxleGlibGVEaW1lbnNpb25zKGZhbHNlKVxuICAgICAgLndpdGhWaWV3cG9ydE1hcmdpbig4KVxuICAgICAgLndpdGhQdXNoKGZhbHNlKTtcblxuICAgIHRoaXMucG9zaXRpb25DaGFuZ2VzU3Vic2NyaXB0aW9uID0gc3RyYXRlZ3kucG9zaXRpb25DaGFuZ2VzXG4gICAgICAucGlwZShtYXAoY2hhbmdlID0+IGdldFBsYWNlbWVudE5hbWUoY2hhbmdlLCB0aGlzLnBsYWNlbWVudCkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKVxuICAgICAgLnN1YnNjcmliZSgocGxhY2VtZW50OiBQbGFjZW1lbnQpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXAoJ3BsYWNlbWVudCcsIHBsYWNlbWVudCk7XG4gICAgICB9KTtcblxuICAgIHRoaXMub3ZlcmxheVJlZiA9IHRoaXMub3ZlcmxheS5jcmVhdGUoe1xuICAgICAgcG9zaXRpb25TdHJhdGVneTogc3RyYXRlZ3ksXG4gICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpLFxuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheVJlZjtcbiAgfVxuXG4gIC8qKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCB0b29sdGlwLiAqL1xuICBwcml2YXRlIHVwZGF0ZVBvc2l0aW9uKCk6IHZvaWQge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gPEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneT50aGlzLm92ZXJsYXlSZWYuZ2V0Q29uZmlnKCkucG9zaXRpb25TdHJhdGVneTtcblxuICAgIHBvc2l0aW9uLndpdGhQb3NpdGlvbnMoW1xuICAgICAgUE9TSVRJT05fTUFQW3RoaXMucGxhY2VtZW50XS5wb3NpdGlvbixcbiAgICAgIC4uLkRFRkFVTFRfVE9PTFRJUF9QT1NJVElPTlMsXG4gICAgXSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVRvb2x0aXAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLnRvb2x0aXBbIGtleSBdID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGlucHV0cyBvZiBjaGlsZCBjb21wb25lbnRzIHdoZW4gdGhpcyBjb21wb25lbnQncyBpbnB1dHMgY2hhbmdlLlxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVQcm94aWVzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgLmZpbHRlcihrZXkgPT4gdGhpcy5uZWVkUHJveHlQcm9wZXJ0aWVzLmhhcyhrZXkpKVxuICAgICAgLmZvckVhY2goa2V5ID0+IHRoaXMudXBkYXRlVG9vbHRpcChrZXksIHRoaXNba2V5XSkpO1xuICB9XG59XG4iXX0=