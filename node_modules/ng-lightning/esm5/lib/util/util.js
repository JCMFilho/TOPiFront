import { __assign, __read, __spread } from "tslib";
// Check if given value is integer. Cast strings as potential integers as well.
// See: http://stackoverflow.com/questions/14636536/how-to-check-if-a-variable-is-an-integer-in-javascript
export function isInt(value) {
    if (isNaN(value)) {
        return false;
    }
    var x = parseFloat(value);
    // tslint:disable-next-line:no-bitwise
    return (x | 0) === x;
}
// Similar to `lodash.isobject`
export function isObject(value) {
    var type = typeof value;
    return !!value && (type === 'object' || type === 'function');
}
// Generate a unique id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
export function uniqueId(prefix) {
    if (prefix === void 0) { prefix = 'uid'; }
    return "ngl_" + prefix + "_" + ++idCounter;
}
export function replaceClass(instance, oldClass, newClass) {
    if (oldClass && oldClass !== newClass) {
        setClass(instance, oldClass, false);
    }
    if (newClass) {
        setClass(instance, newClass, true);
    }
}
function setClass(instance, klasses, isAdd) {
    if (klasses) {
        (Array.isArray(klasses) ? klasses : [klasses]).forEach(function (k) {
            instance.renderer[isAdd ? 'addClass' : 'removeClass'](instance.element.nativeElement, k);
        });
    }
}
export function ngClassCombine(ngClasses, customClasses) {
    if (!ngClasses) {
        return customClasses;
    }
    // Convert string and Set to array
    if (typeof ngClasses === 'string') {
        ngClasses = ngClasses.split(/\s+/);
    }
    else if (ngClasses instanceof Set) {
        var a_1 = [];
        ngClasses.forEach(function (v) { return a_1.push(v); });
        ngClasses = a_1;
    }
    // Convert array to object
    if (Array.isArray(ngClasses)) {
        ngClasses = ngClasses.reduce(function (o, klass) {
            o[klass] = true;
            return o;
        }, {});
    }
    return __assign(__assign({}, ngClasses), customClasses);
}
/**
   * Check whether value is currently selected.
   *
   * @param selection The value(s) currently selected
   * @param value The value in test, whether is (part of) selection or not
   * @param multiple Whether selections can be have multiple values
   */
export function isOptionSelected(value, selection, multiple) {
    // Multiple
    if (multiple) {
        if (!selection) {
            return false;
        }
        return Array.isArray(selection) ? selection.indexOf(value) > -1 : !!selection[value];
    }
    // Single
    return value === selection;
}
export function addOptionToSelection(value, selection, multiple, clearable) {
    var _a;
    if (clearable === void 0) { clearable = false; }
    var next;
    if (multiple) {
        if (!selection) {
            selection = [];
        }
        if (Array.isArray(selection)) {
            // Remove if already there or add to selection
            var index = selection.indexOf(value);
            next = index > -1
                ? __spread(selection.slice(0, index), selection.slice(index + 1)) : __spread(selection, [value]);
        }
        else {
            next = Object.assign({}, selection, (_a = {}, _a[value] = !selection[value], _a));
        }
    }
    else {
        next = selection === value && clearable ? null : value;
    }
    return next;
}
export function menuItemScroll(container, domItem, scrollPadding) {
    if (scrollPadding === void 0) { scrollPadding = 4; }
    if (domItem.offsetHeight - container.scrollTop + domItem.offsetTop >=
        container.offsetHeight) {
        container.scrollTop =
            domItem.offsetHeight +
                domItem.offsetTop -
                container.offsetHeight +
                scrollPadding;
    }
    else if (domItem.offsetTop <= container.scrollTop) {
        container.scrollTop = domItem.offsetTop - scrollPadding;
    }
}
export function trapEvent(event) {
    if (!event) {
        return;
    }
    event.preventDefault();
    event.stopPropagation();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLWxpZ2h0bmluZy8iLCJzb3VyY2VzIjpbImxpYi91dGlsL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUVBLCtFQUErRTtBQUMvRSwwR0FBMEc7QUFDMUcsTUFBTSxVQUFVLEtBQUssQ0FBQyxLQUFVO0lBQzlCLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ2hCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFNLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsc0NBQXNDO0lBQ3RDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLENBQUM7QUFFRCwrQkFBK0I7QUFDL0IsTUFBTSxVQUFVLFFBQVEsQ0FBQyxLQUFVO0lBQ2pDLElBQU0sSUFBSSxHQUFHLE9BQU8sS0FBSyxDQUFDO0lBQzFCLE9BQU8sQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksS0FBSyxRQUFRLElBQUksSUFBSSxLQUFLLFVBQVUsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFFRCxrRUFBa0U7QUFDbEUsZ0NBQWdDO0FBQ2hDLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztBQUNsQixNQUFNLFVBQVUsUUFBUSxDQUFDLE1BQWM7SUFBZCx1QkFBQSxFQUFBLGNBQWM7SUFDckMsT0FBTyxTQUFPLE1BQU0sU0FBSSxFQUFFLFNBQVcsQ0FBQztBQUN4QyxDQUFDO0FBTUQsTUFBTSxVQUFVLFlBQVksQ0FBQyxRQUF1QixFQUFFLFFBQTJCLEVBQUUsUUFBNEI7SUFDN0csSUFBSSxRQUFRLElBQUksUUFBUSxLQUFLLFFBQVEsRUFBRTtRQUNyQyxRQUFRLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUNyQztJQUNELElBQUksUUFBUSxFQUFFO1FBQ1osUUFBUSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsSUFBSSxD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IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vLyBDaGVjayBpZiBnaXZlbiB2YWx1ZSBpcyBpbnRlZ2VyLiBDYXN0IHN0cmluZ3MgYXMgcG90ZW50aWFsIGludGVnZXJzIGFzIHdlbGwuXG4vLyBTZWU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ2MzY1MzYvaG93LXRvLWNoZWNrLWlmLWEtdmFyaWFibGUtaXMtYW4taW50ZWdlci1pbi1qYXZhc2NyaXB0XG5leHBvcnQgZnVuY3Rpb24gaXNJbnQodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgcmV0dXJuICh4IHwgMCkgPT09IHg7XG59XG5cbi8vIFNpbWlsYXIgdG8gYGxvZGFzaC5pc29iamVjdGBcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLy8gR2VuZXJhdGUgYSB1bmlxdWUgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4vLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxubGV0IGlkQ291bnRlciA9IDA7XG5leHBvcnQgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4ID0gJ3VpZCcpIHtcbiAgcmV0dXJuIGBuZ2xfJHtwcmVmaXh9XyR7KytpZENvdW50ZXJ9YDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUmVwbGFjZUNsYXNzIHtcbiAgcmVuZGVyZXI6IFJlbmRlcmVyMjtcbiAgZWxlbWVudDogRWxlbWVudFJlZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlQ2xhc3MoaW5zdGFuY2U6IElSZXBsYWNlQ2xhc3MsIG9sZENsYXNzOiBzdHJpbmcgfCBzdHJpbmdbXSwgbmV3Q2xhc3M/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICBpZiAob2xkQ2xhc3MgJiYgb2xkQ2xhc3MgIT09IG5ld0NsYXNzKSB7XG4gICAgc2V0Q2xhc3MoaW5zdGFuY2UsIG9sZENsYXNzLCBmYWxzZSk7XG4gIH1cbiAgaWYgKG5ld0NsYXNzKSB7XG4gICAgc2V0Q2xhc3MoaW5zdGFuY2UsIG5ld0NsYXNzLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDbGFzcyhpbnN0YW5jZTogSVJlcGxhY2VDbGFzcywga2xhc3Nlczogc3RyaW5nIHwgc3RyaW5nW10sIGlzQWRkOiBib29sZWFuKSB7XG4gIGlmIChrbGFzc2VzKSB7XG4gICAgKEFycmF5LmlzQXJyYXkoa2xhc3NlcykgPyBrbGFzc2VzIDogW2tsYXNzZXNdKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgaW5zdGFuY2UucmVuZGVyZXJbaXNBZGQgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oaW5zdGFuY2UuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBrKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmdDbGFzc0NvbWJpbmUobmdDbGFzc2VzOiBzdHJpbmcgfCBzdHJpbmdbXSB8IFNldDxzdHJpbmc+IHwgeyBba2xhc3M6IHN0cmluZ106IGFueSB9LCBjdXN0b21DbGFzc2VzOiB7IFtrbGFzczogc3RyaW5nXTogYW55IH0pIHtcbiAgaWYgKCFuZ0NsYXNzZXMpIHtcbiAgICByZXR1cm4gY3VzdG9tQ2xhc3NlcztcbiAgfVxuXG4gIC8vIENvbnZlcnQgc3RyaW5nIGFuZCBTZXQgdG8gYXJyYXlcbiAgaWYgKHR5cGVvZiBuZ0NsYXNzZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgbmdDbGFzc2VzID0gbmdDbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gIH0gZWxzZSBpZiAobmdDbGFzc2VzIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgY29uc3QgYSA9IFtdO1xuICAgIG5nQ2xhc3Nlcy5mb3JFYWNoKHYgPT4gYS5wdXNoKHYpKTtcbiAgICBuZ0NsYXNzZXMgPSBhO1xuICB9XG5cbiAgLy8gQ29udmVydCBhcnJheSB0byBvYmplY3RcbiAgaWYgKEFycmF5LmlzQXJyYXkobmdDbGFzc2VzKSkge1xuICAgIG5nQ2xhc3NlcyA9IG5nQ2xhc3Nlcy5yZWR1Y2UoKG86IE9iamVjdCwga2xhc3M6IHN0cmluZykgPT4ge1xuICAgICAgb1trbGFzc10gPSB0cnVlO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSwge30pO1xuICB9XG5cbiAgcmV0dXJuIHsuLi5uZ0NsYXNzZXMsIC4uLmN1c3RvbUNsYXNzZXN9O1xufVxuXG5cbi8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHZhbHVlIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiBUaGUgdmFsdWUocykgY3VycmVudGx5IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgaW4gdGVzdCwgd2hldGhlciBpcyAocGFydCBvZikgc2VsZWN0aW9uIG9yIG5vdFxuICAgKiBAcGFyYW0gbXVsdGlwbGUgV2hldGhlciBzZWxlY3Rpb25zIGNhbiBiZSBoYXZlIG11bHRpcGxlIHZhbHVlc1xuICAgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wdGlvblNlbGVjdGVkKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBhbnksIHNlbGVjdGlvbjogYW55IHwgYW55W10sIG11bHRpcGxlOiBib29sZWFuKTogYm9vbGVhbiB7XG4gIC8vIE11bHRpcGxlXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIGlmICghc2VsZWN0aW9uKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNlbGVjdGlvbikgPyBzZWxlY3Rpb24uaW5kZXhPZih2YWx1ZSkgPiAtMSA6ICEhc2VsZWN0aW9uW3ZhbHVlXTtcbiAgfVxuXG4gIC8vIFNpbmdsZVxuICByZXR1cm4gdmFsdWUgPT09IHNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZE9wdGlvblRvU2VsZWN0aW9uKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBhbnksIHNlbGVjdGlvbjogYW55IHwgYW55W10sIG11bHRpcGxlOiBib29sZWFuLCBjbGVhcmFibGUgPSBmYWxzZSkge1xuICBsZXQgbmV4dDogYW55O1xuICBpZiAobXVsdGlwbGUpIHtcbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgc2VsZWN0aW9uID0gW107XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdGlvbikpIHtcbiAgICAgIC8vIFJlbW92ZSBpZiBhbHJlYWR5IHRoZXJlIG9yIGFkZCB0byBzZWxlY3Rpb25cbiAgICAgIGNvbnN0IGluZGV4ID0gc2VsZWN0aW9uLmluZGV4T2YodmFsdWUpO1xuICAgICAgbmV4dCA9IGluZGV4ID4gLTFcbiAgICAgICAgPyBbLi4uc2VsZWN0aW9uLnNsaWNlKDAsIGluZGV4KSwgLi4uc2VsZWN0aW9uLnNsaWNlKGluZGV4ICsgMSldXG4gICAgICAgIDogWy4uLnNlbGVjdGlvbiwgdmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgc2VsZWN0aW9uLCB7IFt2YWx1ZV06ICFzZWxlY3Rpb25bdmFsdWVdIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gc2VsZWN0aW9uID09PSB2YWx1ZSAmJiBjbGVhcmFibGUgPyBudWxsIDogdmFsdWU7XG4gIH1cblxuICByZXR1cm4gbmV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbnVJdGVtU2Nyb2xsIChjb250YWluZXIsIGRvbUl0ZW0sIHNjcm9sbFBhZGRpbmcgPSA0KSB7XG4gIGlmIChcbiAgICBkb21JdGVtLm9mZnNldEhlaWdodCAtIGNvbnRhaW5lci5zY3JvbGxUb3AgKyBkb21JdGVtLm9mZnNldFRvcCA+PVxuICAgIGNvbnRhaW5lci5vZmZzZXRIZWlnaHRcbiAgKSB7XG4gICAgY29udGFpbmVyLnNjcm9sbFRvcCA9XG4gICAgICBkb21JdGVtLm9mZnNldEhlaWdodCArXG4gICAgICBkb21JdGVtLm9mZnNldFRvcCAtXG4gICAgICBjb250YWluZXIub2Zmc2V0SGVpZ2h0ICtcbiAgICAgIHNjcm9sbFBhZGRpbmc7XG4gIH0gZWxzZSBpZiAoZG9tSXRlbS5vZmZzZXRUb3AgPD0gY29udGFpbmVyLnNjcm9sbFRvcCkge1xuICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBkb21JdGVtLm9mZnNldFRvcCAtIHNjcm9sbFBhZGRpbmc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYXBFdmVudChldmVudDogRXZlbnQpIHtcbiAgaWYgKCFldmVudCkgeyByZXR1cm47IH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG4iXX0=