import { __decorate, __metadata, __param } from "tslib";
import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy, OnChanges, TemplateRef, OnDestroy, ViewChildren, QueryList, SimpleChanges, ContentChild, ViewChild, NgZone, ElementRef, ChangeDetectorRef, Optional, Inject } from '@angular/core';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { CdkOverlayOrigin, CdkConnectedOverlay } from '@angular/cdk/overlay';
import { take } from 'rxjs/operators';
import { DEFAULT_DROPDOWN_POSITIONS } from '../util/overlay-position';
import { uniqueId, isOptionSelected, addOptionToSelection } from '../util/util';
import { InputBoolean, InputNumber } from '../util/convert';
import { NglComboboxOption } from './combobox-option';
import { NglComboboxInput } from './combobox-input';
import { NglComboboxService } from './combobox.service';
import { NglComboboxConfig, NGL_COMBOBOX_CONFIG } from './config';
let NglCombobox = class NglCombobox {
    constructor(defaultConfig, ngZone, cd, service) {
        this.ngZone = ngZone;
        this.cd = cd;
        this.service = service;
        this.variant = 'base';
        this.uid = uniqueId('combobox');
        this.open = false;
        this.openChange = new EventEmitter();
        this.selectionChange = new EventEmitter();
        this.multiple = false;
        this.visibleLength = 5;
        this.closeOnSelection = true;
        this.overlayWidth = 0;
        this.overlayPositions = [...DEFAULT_DROPDOWN_POSITIONS['left']];
        this.selectionValueFn = (selection) => {
            if (selection.length > 0) {
                if (this.multiple && this.isLookup) {
                    return '';
                }
                return selection.length === 1 ? selection[0] : `${selection.length} options selected`;
            }
            return '';
        };
        const config = Object.assign(Object.assign({}, new NglComboboxConfig()), defaultConfig);
        this.loadingLabel = config.loadingLabel;
        this.noOptionsFound = config.noOptionsFound;
        this.removeSelectedLabel = config.removeSelectedLabel;
        this.service.combobox = this;
        // this.service.openChange = this.openChange;
    }
    set data(data) {
        this._data = (data || []).map((d) => {
            if (typeof d === 'string') {
                // Support array of strings as options, by mapping to NglComboboxOptionItem
                return { value: d, label: d };
            }
            else if (!d.label) {
                // Use `value` if missing `label`
                return Object.assign(Object.assign({}, d), { label: d.value });
            }
            return d;
        });
    }
    get data() {
        return this._data;
    }
    get activeOption() {
        return this.keyManager ? this.keyManager.activeItem : null;
    }
    get selectedOptions() {
        return this.data ? this.data.filter(d => this.isSelected(d.value)) : [];
    }
    get isLookup() {
        return this.variant === 'lookup';
    }
    get hasLookupSingleSelection() {
        return this.isLookup && !this.multiple && this.selectedOptions.length > 0;
    }
    ngOnChanges(changes) {
        if (changes.selection) {
            this.calculateDisplayValue();
        }
    }
    onAttach() {
        // Same width as the trigger element
        this.overlayWidth = this.overlayOrigin.elementRef.nativeElement.offsetWidth;
        this.cd.detectChanges();
        this.keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        // Activate selected item or first option
        const selectedOption = this.options.find(o => o.selected);
        if (selectedOption) {
            this.keyManager.setActiveItem(selectedOption);
        }
        else {
            this.keyManager.setFirstItemActive();
        }
        // Listen to button presses if picklist to activate matching option
        this.keyboardSubscribe(this.variant === 'base');
        // When it is open we listen for option changes in order to fix active option and handle scroll
        this.optionChangesSubscription = this.options.changes.subscribe(() => {
            if (!this.activeOption || this.options.toArray().indexOf(this.activeOption) === -1) {
                // Activate first option if active one is destroyed
                this.keyManager.setFirstItemActive();
            }
            else {
                this.activeOption.scrollIntoView();
            }
            this.updateMenuHeight();
        });
        this.updateMenuHeight();
    }
    onDetach() {
        if (this.open) {
            this.close();
            return;
        }
        // Clear aria-activedescendant when menu is closed
        this.inputEl.setAriaActiveDescendant(null);
        this.detach();
    }
    trackByOption(index, option) {
        return option.value;
    }
    dropdownClass() {
        return {
            [`slds-dropdown_length-${this.visibleLength}`]: this.visibleLength > 0,
        };
    }
    inputIconRight() {
        return this.isLookup ? 'utility:search' : 'utility:down';
    }
    hasNoMatches() {
        return this.isLookup && this.data.length === 0 && !this.loadingMore;
    }
    onOptionSelection(option = this.activeOption) {
        const selection = addOptionToSelection(option.value, this.selection, this.multiple);
        this.selectionChange.emit(selection);
        if (this.closeOnSelection) {
            this.close();
        }
    }
    // Trigger by clear button on Lookup
    onClearSelection() {
        this.selectionChange.emit(null);
        setTimeout(() => this.inputEl.focus(), 0);
    }
    /**
     * Check whether value is currently selected.
     *
     * @param value The value in test, whether is (part of) selection or not
     */
    isSelected(value) {
        return isOptionSelected(value, this.selection, this.multiple);
    }
    ngOnDestroy() {
        this.detach();
    }
    close() {
        this.openChange.emit(false);
    }
    detach() {
        this.keyboardSubscribe(false);
        this.keyManager = null;
        if (this.optionChangesSubscription) {
            this.optionChangesSubscription.unsubscribe();
            this.optionChangesSubscription = null;
        }
    }
    calculateDisplayValue() {
        const value = this.selectionValueFn(this.selectedOptions.map(option => option.label));
        this.inputEl.setValue(value);
    }
    keyboardSubscribe(listen) {
        if (this.keyboardSubscription) {
            this.keyboardSubscription.unsubscribe();
            this.keyboardSubscription = null;
        }
        if (listen) {
            this.keyboardSubscription = this.inputEl.keyboardBuffer$.subscribe((pattern) => {
                pattern = pattern.toLocaleLowerCase();
                const options = this.options.toArray();
                const activeIndex = this.activeOption ? this.keyManager.activeItemIndex + 1 : 0;
                for (let i = 0, n = options.length; i < n; i++) {
                    const index = (activeIndex + i) % n;
                    const option = options[index];
                    if (!option.disabled && option.label.toLocaleLowerCase().substr(0, pattern.length) === pattern) {
                        this.keyManager.setActiveItem(option);
                        break;
                    }
                }
            });
        }
    }
    updateMenuHeight() {
        this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
            const { overlayRef } = this.cdkOverlay;
            const height = this.dropdownElementRef.nativeElement.offsetHeight;
            overlayRef.updateSize({
                minHeight: height + 4,
            });
            overlayRef.updatePosition();
        });
    }
};
NglCombobox.ctorParameters = () => [
    { type: NglComboboxConfig, decorators: [{ type: Optional }, { type: Inject, args: [NGL_COMBOBOX_CONFIG,] }] },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: NglComboboxService }
];
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCombobox.prototype, "variant", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "label", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "open", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "openChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selection", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selectionChange", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "multiple", void 0);
__decorate([
    Input(), InputNumber(),
    __metadata("design:type", Number)
], NglCombobox.prototype, "visibleLength", void 0);
__decorate([
    ContentChild(NglComboboxInput, { static: true }),
    __metadata("design:type", NglComboboxInput)
], NglCombobox.prototype, "inputEl", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCombobox.prototype, "loading", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Boolean)
], NglCombobox.prototype, "loadingMore", void 0);
__decorate([
    Input(), InputBoolean(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "closeOnSelection", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCombobox.prototype, "loadingLabel", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCombobox.prototype, "noOptionsFound", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NglCombobox.prototype, "removeSelectedLabel", void 0);
__decorate([
    ViewChildren(NglComboboxOption),
    __metadata("design:type", QueryList)
], NglCombobox.prototype, "options", void 0);
__decorate([
    Input('options'),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], NglCombobox.prototype, "data", null);
__decorate([
    ViewChild('overlayOrigin', { static: true }),
    __metadata("design:type", CdkOverlayOrigin)
], NglCombobox.prototype, "overlayOrigin", void 0);
__decorate([
    ViewChild('cdkOverlay'),
    __metadata("design:type", CdkConnectedOverlay)
], NglCombobox.prototype, "cdkOverlay", void 0);
__decorate([
    ViewChild('dropdown'),
    __metadata("design:type", ElementRef)
], NglCombobox.prototype, "dropdownElementRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NglCombobox.prototype, "selectionValueFn", void 0);
NglCombobox = __decorate([
    Component({
        selector: 'ngl-combobox',
        changeDetection: ChangeDetectionStrategy.OnPush,
        template: "\n<label [nglFormLabel]=\"label\" [attr.for]=\"inputEl.id\"></label>\n<div class=\"slds-form-element__control\">\n  <div class=\"slds-combobox_container\" [class.slds-has-selection]=\"hasLookupSingleSelection\">\n    <div class=\"slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click\" [attr.aria-expanded]=\"open\" aria-haspopup=\"listbox\" role=\"combobox\" [class.slds-is-open]=\"open\" [attr.aria-owns]=\"uid\">\n      <div class=\"slds-combobox__form-element slds-input-has-icon\" role=\"none\" cdkOverlayOrigin #overlayOrigin=\"cdkOverlayOrigin\" [class.slds-input-has-icon_group-right]=\"loading\" [class.slds-input-has-icon_right]=\"!loading\">\n        <ng-content select=\"input\"></ng-content>\n        <div class=\"slds-input__icon-group slds-input__icon-group_right\" *ngIf=\"loading; else iconRight\">\n          <div class=\"slds-spinner slds-spinner_brand slds-spinner_x-small slds-input__spinner\" role=\"status\"><span class=\"slds-assistive-text\">{{ loadingLabel }}</span>\n            <div class=\"slds-spinner__dot-a\"></div>\n            <div class=\"slds-spinner__dot-b\"></div>\n          </div>\n          <ng-template [ngTemplateOutlet]=\"iconRight\"></ng-template>\n        </div>\n        <ng-template #iconRight>\n          <button class=\"slds-button slds-button_icon slds-input__icon slds-input__icon_right\" *ngIf=\"hasLookupSingleSelection; else iconTpl\" type=\"button\" (click)=\"onClearSelection()\" [title]=\"removeSelectedLabel\">\n            <svg class=\"slds-button__icon\" nglIconName=\"utility:close\"></svg><span class=\"slds-assistive-text\">{{ removeSelectedLabel }}</span>\n          </button>\n        </ng-template>\n        <ng-template #iconTpl><span class=\"slds-icon_container slds-input__icon slds-input__icon_right\">\n            <svg class=\"slds-icon slds-icon_x-small slds-icon-text-default\" [nglIconName]=\"inputIconRight()\"></svg></span></ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n<ng-template cdkConnectedOverlay #cdkOverlay=\"cdkConnectedOverlay\" [cdkConnectedOverlayPositions]=\"overlayPositions\" [cdkConnectedOverlayOrigin]=\"overlayOrigin\" [cdkConnectedOverlayMinWidth]=\"overlayWidth\" [cdkConnectedOverlayOpen]=\"open\" (nglOverlayScrolledOutsideView)=\"close()\" (attach)=\"onAttach()\" (detach)=\"onDetach()\">\n  <div class=\"slds-dropdown slds-dropdown_fluid\" #dropdown [attr.id]=\"uid\" role=\"listbox\" [ngClass]=\"dropdownClass()\" (mousedown)=\"$event.preventDefault()\">\n    <ul class=\"slds-listbox slds-listbox_vertical\" role=\"presentation\">\n      <li *ngFor=\"let d of data; trackBy: trackByOption\" nglComboboxOption [value]=\"d.value\" [label]=\"d.label\" [disabled]=\"d.disabled\" [selected]=\"isSelected(d.value)\"></li>\n      <li class=\"slds-listbox__item\" *ngIf=\"loadingMore\" role=\"presentation\">\n        <div class=\"slds-align_absolute-center slds-p-top_medium\">\n          <div class=\"slds-spinner slds-spinner_x-small slds-spinner_inline\" role=\"status\">\n            <div class=\"slds-assistive-text\">{{ loadingLabel }}</div>\n            <div class=\"slds-spinner__dot-a\"></div>\n            <div class=\"slds-spinner__dot-b\"></div>\n          </div>\n        </div>\n      </li>\n      <li class=\"slds-listbox__item\" *ngIf=\"hasNoMatches()\" role=\"presentation\" aria-live=\"polite\">\n        <div class=\"slds-align_absolute-center\"><span role=\"status\">{{ noOptionsFound }}</span></div>\n      </li>\n    </ul>\n  </div>\n</ng-template>",
        host: {
            'class.slds-form-element': 'true',
        },
        providers: [NglComboboxService]
    }),
    __param(0, Optional()), __param(0, Inject(NGL_COMBOBOX_CONFIG)),
    __metadata("design:paramtypes", [NglComboboxConfig,
        NgZone,
        ChangeDetectorRef,
        NglComboboxService])
], NglCombobox);
export { NglCombobox };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tYm9ib3guanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1saWdodG5pbmcvIiwic291cmNlcyI6WyJsaWIvY29tYm9ib3hlcy9jb21ib2JveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFDbEcsWUFBWSxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekosT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDL0QsT0FBTyxFQUEwQixnQkFBZ0IsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXJHLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0QyxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RSxPQUFPLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixFQUFFLG9CQUFvQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDcEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDeEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBaUJsRSxJQUFhLFdBQVcsR0FBeEIsTUFBYSxXQUFXO0lBMEd0QixZQUFxRCxhQUFnQyxF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LFdBQUEsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUE7cUNBQWdCLGlCQUFpQjtRQUN6RCxNQUFNO1FBQ1YsaUJBQWlCO1FBQ1osa0JBQWtCO0dBN0dwQyxXQUFXLENBNFF2QjtTQTVRWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBPbkNoYW5nZXMsIFRlbXBsYXRlUmVmLCBPbkRlc3Ryb3ksXG4gICAgICAgICBWaWV3Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgU2ltcGxlQ2hhbmdlcywgQ29udGVudENoaWxkLCBWaWV3Q2hpbGQsIE5nWm9uZSwgRWxlbWVudFJlZiwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE9wdGlvbmFsLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ29ubmVjdGlvblBvc2l0aW9uUGFpciwgQ2RrT3ZlcmxheU9yaWdpbiwgQ2RrQ29ubmVjdGVkT3ZlcmxheSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERFRkFVTFRfRFJPUERPV05fUE9TSVRJT05TIH0gZnJvbSAnLi4vdXRpbC9vdmVybGF5LXBvc2l0aW9uJztcbmltcG9ydCB7IHVuaXF1ZUlkLCBpc09wdGlvblNlbGVjdGVkLCBhZGRPcHRpb25Ub1NlbGVjdGlvbiB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBJbnB1dEJvb2xlYW4sIElucHV0TnVtYmVyIH0gZnJvbSAnLi4vdXRpbC9jb252ZXJ0JztcbmltcG9ydCB7IE5nbENvbWJvYm94T3B0aW9uIH0gZnJvbSAnLi9jb21ib2JveC1vcHRpb24nO1xuaW1wb3J0IHsgTmdsQ29tYm9ib3hJbnB1dCB9IGZyb20gJy4vY29tYm9ib3gtaW5wdXQnO1xuaW1wb3J0IHsgTmdsQ29tYm9ib3hTZXJ2aWNlIH0gZnJvbSAnLi9jb21ib2JveC5zZXJ2aWNlJztcbmltcG9ydCB7IE5nbENvbWJvYm94Q29uZmlnLCBOR0xfQ09NQk9CT1hfQ09ORklHIH0gZnJvbSAnLi9jb25maWcnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5nbENvbWJvYm94T3B0aW9uSXRlbSB7XG4gIHZhbHVlOiBudW1iZXIgfCBzdHJpbmc7XG4gIGxhYmVsPzogc3RyaW5nO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ25nbC1jb21ib2JveCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICB0ZW1wbGF0ZVVybDogJy4vY29tYm9ib3guaHRtbCcsXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3Muc2xkcy1mb3JtLWVsZW1lbnQnOiAndHJ1ZScsXG4gIH0sXG4gIHByb3ZpZGVyczogWyBOZ2xDb21ib2JveFNlcnZpY2UgXSxcbn0pXG5leHBvcnQgY2xhc3MgTmdsQ29tYm9ib3ggaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG5cbiAgQElucHV0KCkgcmVhZG9ubHkgdmFyaWFudDogJ2Jhc2UnIHwgJ2xvb2t1cCcgPSAnYmFzZSc7XG5cbiAgQElucHV0KCkgcmVhZG9ubHkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgcmVhZG9ubHkgdWlkID0gdW5pcXVlSWQoJ2NvbWJvYm94Jyk7XG5cbiAgQElucHV0KCkgQElucHV0Qm9vbGVhbigpIHJlYWRvbmx5IG9wZW4gPSBmYWxzZTtcblxuICBAT3V0cHV0KCkgb3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICBASW5wdXQoKSByZWFkb25seSBzZWxlY3Rpb246IGFueTtcblxuICBAT3V0cHV0KCkgc2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSByZWFkb25seSBtdWx0aXBsZSA9IGZhbHNlO1xuXG4gIEBJbnB1dCgpIEBJbnB1dE51bWJlcigpIHJlYWRvbmx5IHZpc2libGVMZW5ndGg6IDUgfCA3IHwgMTAgPSA1O1xuXG4gIEBDb250ZW50Q2hpbGQoTmdsQ29tYm9ib3hJbnB1dCwgeyBzdGF0aWM6IHRydWUgfSkgaW5wdXRFbDogTmdsQ29tYm9ib3hJbnB1dDtcblxuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgcmVhZG9ubHkgbG9hZGluZzogYm9vbGVhbjtcblxuICBASW5wdXQoKSBASW5wdXRCb29sZWFuKCkgcmVhZG9ubHkgbG9hZGluZ01vcmU6IGJvb2xlYW47XG5cbiAgQElucHV0KCkgQElucHV0Qm9vbGVhbigpIHJlYWRvbmx5IGNsb3NlT25TZWxlY3Rpb24gPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUZXh0IGFkZGVkIHRvIGxvYWRpbmcgc3Bpbm5lci5cbiAgICovXG4gIEBJbnB1dCgpIGxvYWRpbmdMYWJlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUZXh0IG1lc3NhZ2UgdGhhdCByZW5kZXJzIHdoZW4gbm8gbWF0Y2hlcyBmb3VuZC5cbiAgICovXG4gIEBJbnB1dCgpIG5vT3B0aW9uc0ZvdW5kOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRleHQgZm9yIHJlbW92aW5nIHNpbmdsZSBzZWxlY3RlZCBvcHRpb24uXG4gICAqL1xuICBASW5wdXQoKSByZW1vdmVTZWxlY3RlZExhYmVsOiBzdHJpbmc7XG5cbiAgQFZpZXdDaGlsZHJlbihOZ2xDb21ib2JveE9wdGlvbikgcmVhZG9ubHkgb3B0aW9uczogUXVlcnlMaXN0PE5nbENvbWJvYm94T3B0aW9uPjtcblxuICBASW5wdXQoJ29wdGlvbnMnKSBzZXQgZGF0YShkYXRhOiBhbnlbXSkge1xuICAgIHRoaXMuX2RhdGEgPSAoZGF0YSB8fCBbXSkubWFwKChkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgYXJyYXkgb2Ygc3RyaW5ncyBhcyBvcHRpb25zLCBieSBtYXBwaW5nIHRvIE5nbENvbWJvYm94T3B0aW9uSXRlbVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogZCwgbGFiZWw6IGQgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWQubGFiZWwpIHtcbiAgICAgICAgLy8gVXNlIGB2YWx1ZWAgaWYgbWlzc2luZyBgbGFiZWxgXG4gICAgICAgIHJldHVybiB7IC4uLmQsIGxhYmVsOiBkLnZhbHVlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ292ZXJsYXlPcmlnaW4nLCB7IHN0YXRpYzogdHJ1ZSB9KSBvdmVybGF5T3JpZ2luOiBDZGtPdmVybGF5T3JpZ2luO1xuXG4gIEBWaWV3Q2hpbGQoJ2Nka092ZXJsYXknKSBjZGtPdmVybGF5OiBDZGtDb25uZWN0ZWRPdmVybGF5O1xuXG4gIEBWaWV3Q2hpbGQoJ2Ryb3Bkb3duJykgZHJvcGRvd25FbGVtZW50UmVmOiBFbGVtZW50UmVmO1xuXG4gIG92ZXJsYXlXaWR0aCA9IDA7XG5cbiAgb3ZlcmxheVBvc2l0aW9uczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdID0gWy4uLkRFRkFVTFRfRFJPUERPV05fUE9TSVRJT05TWydsZWZ0J11dO1xuXG4gIC8qKiBNYW5hZ2VzIGFjdGl2ZSBpdGVtIGluIG9wdGlvbiBsaXN0IGJhc2VkIG9uIGtleSBldmVudHMuICovXG4gIGtleU1hbmFnZXI6IEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyPE5nbENvbWJvYm94T3B0aW9uPjtcblxuICBwcml2YXRlIG9wdGlvbkNoYW5nZXNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBwcml2YXRlIF9kYXRhOiBOZ2xDb21ib2JveE9wdGlvbkl0ZW1bXSB8IG51bGw7XG5cbiAgcHJpdmF0ZSBrZXlib2FyZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIEBJbnB1dCgpIHNlbGVjdGlvblZhbHVlRm4gPSAoc2VsZWN0aW9uOiBzdHJpbmdbXSk6IHN0cmluZyA9PiB7XG4gICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aXBsZSAmJiB0aGlzLmlzTG9va3VwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Rpb24ubGVuZ3RoID09PSAxID8gc2VsZWN0aW9uWzBdIDogYCR7c2VsZWN0aW9uLmxlbmd0aH0gb3B0aW9ucyBzZWxlY3RlZGA7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGdldCBhY3RpdmVPcHRpb24oKTogTmdsQ29tYm9ib3hPcHRpb24gfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5rZXlNYW5hZ2VyID8gdGhpcy5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0gOiBudWxsO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGVkT3B0aW9ucygpOiBOZ2xDb21ib2JveE9wdGlvbkl0ZW1bXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSA/IHRoaXMuZGF0YS5maWx0ZXIoZCA9PiB0aGlzLmlzU2VsZWN0ZWQoZC52YWx1ZSkpIDogW107XG4gIH1cblxuICBnZXQgaXNMb29rdXAoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmFyaWFudCA9PT0gJ2xvb2t1cCc7XG4gIH1cblxuICBnZXQgaGFzTG9va3VwU2luZ2xlU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9va3VwICYmICF0aGlzLm11bHRpcGxlICYmIHRoaXMuc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCA+IDA7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBASW5qZWN0KE5HTF9DT01CT0JPWF9DT05GSUcpIGRlZmF1bHRDb25maWc6IE5nbENvbWJvYm94Q29uZmlnLFxuICAgICAgICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgICAgICAgICAgICBwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzZXJ2aWNlOiBOZ2xDb21ib2JveFNlcnZpY2UpIHtcbiAgICBjb25zdCBjb25maWcgPSB7IC4uLm5ldyBOZ2xDb21ib2JveENvbmZpZygpLCAuLi5kZWZhdWx0Q29uZmlnIH07XG4gICAgdGhpcy5sb2FkaW5nTGFiZWwgPSBjb25maWcubG9hZGluZ0xhYmVsO1xuICAgIHRoaXMubm9PcHRpb25zRm91bmQgPSBjb25maWcubm9PcHRpb25zRm91bmQ7XG4gICAgdGhpcy5yZW1vdmVTZWxlY3RlZExhYmVsID0gY29uZmlnLnJlbW92ZVNlbGVjdGVkTGFiZWw7XG5cbiAgICB0aGlzLnNlcnZpY2UuY29tYm9ib3ggPSB0aGlzO1xuICAgIC8vIHRoaXMuc2VydmljZS5vcGVuQ2hhbmdlID0gdGhpcy5vcGVuQ2hhbmdlO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLnNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jYWxjdWxhdGVEaXNwbGF5VmFsdWUoKTtcbiAgICB9XG4gIH1cblxuICBvbkF0dGFjaCgpIHtcbiAgICAvLyBTYW1lIHdpZHRoIGFzIHRoZSB0cmlnZ2VyIGVsZW1lbnRcbiAgICB0aGlzLm92ZXJsYXlXaWR0aCA9IHRoaXMub3ZlcmxheU9yaWdpbi5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICB0aGlzLmtleU1hbmFnZXIgPSBuZXcgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIodGhpcy5vcHRpb25zKS53aXRoV3JhcCgpO1xuXG4gICAgLy8gQWN0aXZhdGUgc2VsZWN0ZWQgaXRlbSBvciBmaXJzdCBvcHRpb25cbiAgICBjb25zdCBzZWxlY3RlZE9wdGlvbiA9IHRoaXMub3B0aW9ucy5maW5kKG8gPT4gby5zZWxlY3RlZCk7XG4gICAgaWYgKHNlbGVjdGVkT3B0aW9uKSB7XG4gICAgICB0aGlzLmtleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShzZWxlY3RlZE9wdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5TWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0ZW4gdG8gYnV0dG9uIHByZXNzZXMgaWYgcGlja2xpc3QgdG8gYWN0aXZhdGUgbWF0Y2hpbmcgb3B0aW9uXG4gICAgdGhpcy5rZXlib2FyZFN1YnNjcmliZSh0aGlzLnZhcmlhbnQgPT09ICdiYXNlJyk7XG5cbiAgICAvLyBXaGVuIGl0IGlzIG9wZW4gd2UgbGlzdGVuIGZvciBvcHRpb24gY2hhbmdlcyBpbiBvcmRlciB0byBmaXggYWN0aXZlIG9wdGlvbiBhbmQgaGFuZGxlIHNjcm9sbFxuICAgIHRoaXMub3B0aW9uQ2hhbmdlc1N1YnNjcmlwdGlvbiA9IHRoaXMub3B0aW9ucy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYWN0aXZlT3B0aW9uIHx8IHRoaXMub3B0aW9ucy50b0FycmF5KCkuaW5kZXhPZih0aGlzLmFjdGl2ZU9wdGlvbikgPT09IC0xKSB7XG4gICAgICAgIC8vIEFjdGl2YXRlIGZpcnN0IG9wdGlvbiBpZiBhY3RpdmUgb25lIGlzIGRlc3Ryb3llZFxuICAgICAgICB0aGlzLmtleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZU9wdGlvbi5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZU1lbnVIZWlnaHQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMudXBkYXRlTWVudUhlaWdodCgpO1xuICB9XG5cbiAgb25EZXRhY2goKSB7XG4gICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGFyaWEtYWN0aXZlZGVzY2VuZGFudCB3aGVuIG1lbnUgaXMgY2xvc2VkXG4gICAgdGhpcy5pbnB1dEVsLnNldEFyaWFBY3RpdmVEZXNjZW5kYW50KG51bGwpO1xuXG4gICAgdGhpcy5kZXRhY2goKTtcbiAgfVxuXG4gIHRyYWNrQnlPcHRpb24oaW5kZXgsIG9wdGlvbjogTmdsQ29tYm9ib3hPcHRpb24pIHtcbiAgICByZXR1cm4gb3B0aW9uLnZhbHVlO1xuICB9XG5cbiAgZHJvcGRvd25DbGFzcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW2BzbGRzLWRyb3Bkb3duX2xlbmd0aC0ke3RoaXMudmlzaWJsZUxlbmd0aH1gXTogdGhpcy52aXNpYmxlTGVuZ3RoID4gMCxcbiAgICB9O1xuICB9XG5cbiAgaW5wdXRJY29uUmlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMb29rdXAgPyAndXRpbGl0eTpzZWFyY2gnIDogJ3V0aWxpdHk6ZG93bic7XG4gIH1cblxuICBoYXNOb01hdGNoZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMb29rdXAgJiYgdGhpcy5kYXRhLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy5sb2FkaW5nTW9yZTtcbiAgfVxuXG4gIG9uT3B0aW9uU2VsZWN0aW9uKG9wdGlvbjogTmdsQ29tYm9ib3hPcHRpb24gPSB0aGlzLmFjdGl2ZU9wdGlvbikge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGFkZE9wdGlvblRvU2VsZWN0aW9uKG9wdGlvbi52YWx1ZSwgdGhpcy5zZWxlY3Rpb24sIHRoaXMubXVsdGlwbGUpO1xuICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlLmVtaXQoc2VsZWN0aW9uKTtcbiAgICBpZiAodGhpcy5jbG9zZU9uU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJpZ2dlciBieSBjbGVhciBidXR0b24gb24gTG9va3VwXG4gIG9uQ2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2UuZW1pdChudWxsKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaW5wdXRFbC5mb2N1cygpLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHZhbHVlIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBpbiB0ZXN0LCB3aGV0aGVyIGlzIChwYXJ0IG9mKSBzZWxlY3Rpb24gb3Igbm90XG4gICAqL1xuICBpc1NlbGVjdGVkKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNPcHRpb25TZWxlY3RlZCh2YWx1ZSwgdGhpcy5zZWxlY3Rpb24sIHRoaXMubXVsdGlwbGUpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGV0YWNoKCkge1xuICAgIHRoaXMua2V5Ym9hcmRTdWJzY3JpYmUoZmFsc2UpO1xuICAgIHRoaXMua2V5TWFuYWdlciA9IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9uQ2hhbmdlc1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5vcHRpb25DaGFuZ2VzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLm9wdGlvbkNoYW5nZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRGlzcGxheVZhbHVlKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zZWxlY3Rpb25WYWx1ZUZuKHRoaXMuc2VsZWN0ZWRPcHRpb25zLm1hcChvcHRpb24gPT4gb3B0aW9uLmxhYmVsKSk7XG4gICAgdGhpcy5pbnB1dEVsLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUga2V5Ym9hcmRTdWJzY3JpYmUobGlzdGVuOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMua2V5Ym9hcmRTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMua2V5Ym9hcmRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMua2V5Ym9hcmRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChsaXN0ZW4pIHtcbiAgICAgIHRoaXMua2V5Ym9hcmRTdWJzY3JpcHRpb24gPSB0aGlzLmlucHV0RWwua2V5Ym9hcmRCdWZmZXIkLnN1YnNjcmliZSgocGF0dGVybikgPT4ge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudG9BcnJheSgpO1xuXG4gICAgICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5hY3RpdmVPcHRpb24gPyB0aGlzLmtleU1hbmFnZXIuYWN0aXZlSXRlbUluZGV4ICsgMSA6IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IChhY3RpdmVJbmRleCArIGkpICUgbjtcbiAgICAgICAgICBjb25zdCBvcHRpb24gPSBvcHRpb25zW2luZGV4XTtcbiAgICAgICAgICBpZiAoIW9wdGlvbi5kaXNhYmxlZCAmJiBvcHRpb24ubGFiZWwudG9Mb2NhbGVMb3dlckNhc2UoKS5zdWJzdHIoMCwgcGF0dGVybi5sZW5ndGgpID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB0aGlzLmtleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShvcHRpb24pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZU1lbnVIZWlnaHQoKSB7XG4gICAgdGhpcy5uZ1pvbmUub25TdGFibGUuYXNPYnNlcnZhYmxlKCkucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgeyBvdmVybGF5UmVmIH0gPSB0aGlzLmNka092ZXJsYXk7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmRyb3Bkb3duRWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgIG92ZXJsYXlSZWYudXBkYXRlU2l6ZSh7XG4gICAgICAgIG1pbkhlaWdodDogaGVpZ2h0ICsgNCxcbiAgICAgIH0pO1xuICAgICAgb3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgIH0pO1xuICB9XG59XG4iXX0=